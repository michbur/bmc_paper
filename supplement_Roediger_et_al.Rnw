\documentclass[a4paper]{article}
%\usepackage{hyperref}
\usepackage[utf8]{inputenc} %unicode support
\usepackage[margins=0.6in]{geometry}
\renewcommand{\thefigure}{S\arabic{figure}}


\title{Supplement to: "chipPCR: an R Package to Pre-Process Amplification Curve 
Data"}
\author{Stefan R\"{o}diger* and Micha\l{} Burdukiewicz and Peter Schierack}

\begin{document}


<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Supplement to: "chipPCR: an R Package to Pre-Process Amplification Curve  Data"}
%\VignetteDepends{chipPCR}
%\VignetteKeywords{amplification curve pro-processing chipPCR R}
%\VignettePackage{chipPCR}
-->

<<captures,warning=FALSE,message=FALSE>>=
fig1_cap <- "The amplification curves were generated with the \\textsl{AmpSim} function. All Cqs are unique due to the use of random value, which were added to the starting Cq of 25. The parameter $noise = 0.03$ adds some scatter to the amplification curve data."
fig2_cap <- "The function provides two modes (\\textbf{A)} is the linear regression. 
\\textbf{B)} Quadratic regression) for the calculation of the Cq. In both cases 
is the highest R squared value determining how many left an right neighbors 
above and the below the used defined threshold level are use."
fig3_cap <- "Data from a ccPCR were analyzed using the th.cyc function using the 
linear regression mode. The threshold level ($r = 50$) was identical for all 
data. The Cq (Ct) are given in minutes. The range used for the calculation of 
the Cq is indicated in red. Negative curves are automatically excluded from the 
analysis if the 90\\% percentile is lower or equal to the threshold level ($r$)."
fig4_cap <- "\\textbf{A)} The raw data of the VIMCFX96\\_60 data set were plotted without 
pre-processing. \\textbf{B)} All amplification curve data were pre-processed 
with the CPP function. The parameter $trans$ was set to $TRUE$, which 
lead to a linear trend correction and base-lining. By default a Savitsky-Golay 
filter was used to smooth the data. The data were normalized between 0 and 1 
($method.norm = 'minmax'$). \\textbf{C)} All Cqs were calculated with 
th.cyc function. The Cq for the raw data was $17.25 \\pm 0.5$ (at $r = 
2575$) and $17.1 \\pm 0.1$ (at $r = 0.1$) for the pre-processed data. Our 
results indicate that the dispersion of the Cq values was slightly lower."
fig5_cap <- "The VIMCFX96\\_60 data set (96-well plate cycler, Bio-Rad CFX96, EvaGreen detection) was used. \\emph{(A)} 
Raw data of all amplification curves. The signals are superimposed to circa 
2200 RFU and the inter-sample baseline and plateau shift is high. Note the 
positive trend (\\textcolor{red}{\\textendash}, fitted with an ordinary least 
squares method) in the background range of cycles 1 to 15. All subsequent plots 
were processed with the CPP function. By default, the curves are 
baselined, smoothed (Savitzky-Golay smoother) and the slop corrected by a linear 
regression ($trans = TRUE$). \\emph{(B)} baselined raw data, \\emph{(C)} 
\\emph{Min-Max normalization}, \\emph{(D)} \\emph{Max normalization}, \\emph{(E)} 
\\emph{lugn-normalization} with a cut off 3\\% and \\emph{(F)} 
\\emph{zscore-normalization}."
fig6_cap <- "\\emph{(A)} AmpSim was used with the parameters XX, YY, ZZ to 
synthesize a qPCR experiment of six dilutions (three replicates per dilution) 
standard samples. The Cqs were determined by the $SDM$ method (solid black 
vertical lines). \\emph{(B)} effcalc was used to automatically perform a 
linear regression. The regression curve (\\textendash) was plotted as the 
decadic logarithm of input concentration versus the Cq. The 95\\% confidence 
interval is shown be the light-blue solid lines."
fig7_cap <- "Data of a VideoScan 
HCU dilution experiment (C54 data set) were analyzed. \\emph{(A)} 
Visualization of the raw data. One of the three dilutions contains a missing 
value due to a sensor error. \\emph{(B, top panel)} The CPP function 
was used to baseline, to remove the missing value (\\textcolor{red}{\\textendash}) 
and to smooth (\\textcolor{black}{\\textendash}, \\textcolor{red}{\\textendash}, 
\\textcolor{green}{\\textendash}) the raw data. \\emph{(B, bottom panel)}. The Cqs 
($SDM$) of the pre-processed data were calculated by diffQ2 (see main 
text) and analyzed with \\textsl{effcalc}. The amplification is approximately at 
87.3~\\%."
fig8_cap <- "\\emph{(A)} Raw data were generated using the 
AmpSim simulation function. \\emph{(B)} A missing value was introduced 
in the transition phase. The missing value was imputed either by \\emph{(C)} 
linear approximation or \\emph{(D)} a cubic spline approximation. The spline 
approximation nearly reconstituted the original curve."
fig9_cap <- "Raw data (\\textbullet) were generated using the AmpSim simulation 
function (see example main text). The inflection point is the point where the 
slope is maximum and the curvature is zero. The first derivative of the 
amplification curve has a first derivative maximum ($FDM$) at the inflection 
point.The second derivative maximum method ($SDM$) needs to differentiate a 
curve to the second order prior to quantification. The second derivative 
exhibits a zero-crossing at the $FDM$. The function $y = f(x)$ is 
numerically derived by five-point stencil. This method do not require any 
assumptions regarding the function f. The function inder
calculates the approximate $SDM$. The $SDM$ might in addition be useful for 
isothermal amplification processes. The $SDM$ is calculated from a derived 
cubic spline. Similarly the first approximate approximate derivative maximum 
($FDM$), second derivative minimum ($SDm$), and approximate second derivative 
center ($SDC$, geometric mean of $SDM$ and $SDm$) are available. $FDM$, $SDm$ 
and $SDC$ values can be used to further characterize the amplification process."
fig10_cap <-  "\\emph{(A)} Plot 
the samples detected with EvaGreen and \\emph{(B)} shows the same samples 
detected with the Hydrolysis probe for MLC-2v. \\emph{(C)} Stripchart 
of the Cq values (\\textbullet) with the median (\\emph{\\textendash}) and the 
median absolute deviation (\\textendash~\\textendash). This result indicates, that 
the variance of the derived from the detection with hydrolysis probes is higher 
than the samples detected with EvaGreen. Note: the $inder$ parameter is set as 
TRUE."
fig11_cap <-  "\\emph{(A)} The \textsl{C126EG595} data set 
was used with 96 replicates of equal starting numbers of template molecules. 
Vertical lines represent the Cq ($SDM$ method) determined with inder
method on amplification curves fitted with a 5-parameter curve function. Curves 
with Cqs less than 14.5 are indicated in red (\\textcolor{red}{\\textendash}). 
\\emph{(B)} Second derivatives of the amplification curves. Note that after 
differentiation all inter sample baseline and plateau shifts are similar. 
\\emph{(C)} Histogram (class width = 0.05 Cq) of the Cq values ($SDM$). Cqs were 
mainly at circa 15.7 (N = 80) while some amplification curves had a Cq less than 
15.5 (N = 16)."
fig12_cap <- "Signal analysis using the \textsl{VIMCFX96\\_60} data set (96-well 
plate cycler (Bio-Rad CFX96)).} All cycles (ROI: 1 -- 40) were analyzed by the 
\textsl{MFIaggr} function. The density plot (right upper panel) and 
quantile-quantile analysis (right lower panel) show no normal distribution. Due 
to the sigmoidal curve structure is the density function bimodal."
@

\maketitle


\begin{abstract} % abstract
\textbf{Background: } %if any
The quantitative real-time polymerase chain reaction (qPCR) and isothermal 
amplification are standard methods for quantification of nucleic acids. Numerous 
real-time read-out technologies with different technical foundation have been 
developed. However, the amplification curve analysis consists of cascaded steps, 
which are carried out similarly in all technologies. Despite the continuous 
interest in amplification based techniques, there are only few transparent tools 
for amplification data pre-processing. It is a major setback especially during 
development of new instruments, when the precise control on raw data is 
indispensable.

\textbf{Results and Conclusion: } %if any
$\emph{chipPCR}$ is an \textbf{R} package for pre-processing and quality 
analysis of amplification curve data from conventional quantitative polymerase 
chain reactions (qPCR) and quantitative isothermal amplification (qIA). This 
supplement provides further details and examples for the  
$\emph{chipPCR}$ package. The package contains several data sets, which were 
generated by helicase dependent amplification (HDA) or polymerase chain reaction 
(PCR) under various temperature conditions and detection systems, such as 
hydrolysis probes and intercalating dyes. Examples for their usage are 
presented herein. We have developed $\emph{chipPCR}$, which is a versatile 
software tailored for the pre-processing of amplification curve data. Its 
utility is elaborated on both real and simulated data sets. The structure of the 
packages is open for integration to Web based and standalone \emph{shiny} 
applications. The \textbf{R} package along codes used for creation of figures 
used in publication is freely available.
\end{abstract}

%create TOC
\tableofcontents

\section{Setting up a work environment}
Although the numbers already contain all accessible information, data 
visualization greatly simplifies further analysis. For example, outputs of the 
\textsl{bg.max()} function can be added to the plots to provide even more 
knowledge about the properties of analyzed experiments. Before the start of any 
analysis, a user must must choose data set and proper tools.

<<load_data,message=FALSE>>=
require(chipPCR)
# Load the drc package for the five-parameter log-logistic fit.
require(drc)
# Load the testdat dataset from the qpcR package without 
# loading the entire package.
data(testdat, package = "qpcR")
@



<<see_data,echo=FALSE,results='asis',message=FALSE>>=
library(knitr)
opts_chunk$set(fig.lp="figure:",tidy=TRUE, tidy.opts=list(width.cutoff=50))

require(xtable)
print(xtable(head(testdat[, 1L:5]), caption = "First six cycles of data.", label = "tdhead"))
@

For purpose of this short presentation, we will limit our analysis to four 
experiments (Table~S\ref{tdhead}).

\subsection*{MFIaggr}

<<MFIaggr_all,fig.show='hold',fig.cap=fig12_cap>>=
plot(MFIaggr(VIMCFX96_60[, 1], VIMCFX96_60[, 2:ncol(VIMCFX96_60)], 
     llul = c(1,40)), CV = FALSE)
@

\subsection*{AmpSim - a function to simulate amplification curves}
  The function \textsl{AmpSim} is a simulator for amplification 
reactions. Use cases include teaching, algorithm testing or the comparison of an 
experimental system to the predicted (''optimal``) model. \textsl{AmpSim} uses a 
5-parameter model (Equation~S\ref{eq:richards}).

\begin{equation} \label{eq:richards}
fluo = bl + \frac{ampl - bl}{1 + \exp{(b.eff * (\log{cyc} - \log{Cq}))}}
\end{equation}

  \textsl{AmpSim} has several parameters, which can be used to simulate an 
amplification curve. $b.eff$ and $Cq$ are most connected with another. Thus 
changing one of them will change both values. $Cq$ can be used to define an 
approximate Cq value. The expression ''approximate Cq value`` is used because 
the calculated Cq value will vary depending on the preferred Cq quantification 
method (e.g., Second Derivative Maximum ($SDM$) method, threshold method). 
\textsl{AmpSim} can be used to simulate data with noise (based on 
\textsl{rnorm}, \emph{stats}), signal-to-noise ratios, photo-bleaching and 
other 
influences on a qPCR reaction. The following example illustrates the use of 
\textsl{AmpSim} (Figure~S\ref{figure:AmpSim_random}).


<<AmpSim_random,warning=FALSE,message=FALSE,fig.show='hold',fig.cap=fig1_cap>>=
# Draw an empty plot for 40 cycles with user defined parameters.

par(las = 0, bty = "n", oma = c(.5,.5,.5,.5))
plot(NA, NA, xlim = c(1,40), ylim = c(0,1.1), xlab = "Cycle", ylab = "RFU")
colors <- rainbow(8)

# Create eight amplification curves. The approximate Cqs are synthesized 
# as temporary Cqs by adding a random value to a starting Cq of 25. Note: 
# ``noise'' is set TRUE with a level of nnl = 0.03. This adds some scatter 
# to the amplification curves.

sim <- sapply(1L:8, function(i) {
  Cq.tmp <- 25 + rnorm(1) * 5
  
  tmp <- AmpSim(1:40, Cq = Cq.tmp, noise = TRUE, nnl = 0.03)
  lines(tmp, col = colors[i], lwd = 2)
  
  # Add the approximate Cq values to the plot
  text(3, 1 - i / 10, paste("Cq ", round(Cq.tmp, 2)), col = colors[i])
})
@




<<thcyc,warning=FALSE,message=FALSE,fig.show='hold',fig.cap=fig2_cap>>=
# Raw data from the VIMCFX96_69 data set.
# Cycles
x <- VIMCFX96_69[, 1]
# Fluoresce values
y <- VIMCFX96_69[, 2]

par(mfrow = c(1,2), las = 0, bty = "n")
# Plot the raw data
plot(x, y, xlab = "Cycle", ylab = "Fluo", main = "Linear regression", 
     pch = 19)
mtext("A", cex = 1.3, side = 3, adj = 0) 
# Calculate the the Cq (Ct) value
res <- th.cyc(x, y, r = 2400, linear = TRUE)
lines(res@input, col = 2, lwd = 2)
# Threshold fluorescence value
abline(h = res@.Data[2], col = 3)
# Calculated Ct value
abline(v = res@.Data[1], col = 4)
legend("topleft", paste("Cq (Ct) = ", round(res[1], 3)))

plot(x, y, xlab = "Cycle", ylab = "Fluo", main = "Quadratic regression", 
     pch = 19)
mtext("B", cex = 1.3, side = 3, adj = 0) 
# Calculate the the Ct value
res <- th.cyc(x, y, r = 2400, linear = FALSE)
lines(res@input, col = 2, lwd = 2)
# Threshold fluorescence value
abline(h = res@.Data[2], col = 3)
# Calculated Ct value
abline(v = res@.Data[1], col = 4)
legend("topleft", paste("Cq (Ct) = ", round(res[1], 3)))
@



	
<<thcyc_ccPCR,fig.show='hold',fig.cap=fig3_cap>>=
# Application of the th.cyc method to determine the Cq from a continuous
# amplification reaction.
par(las = 0, bty = "n", oma = c(.5,.5,.5,.5))
plot(NA, NA, xlim = c(0,80), ylim = c(0,1200), xlab = "Time [min]", 
     ylab = "Voltage [micro V]", main = "ccPCR - Raw Data")

# Threshold level "r" (50 micro Volts)
for (i in c(1,3,5,7)) {
  y.tmp <- capillaryPCR[, i + 1] - mean(capillaryPCR[1L:150, i + 1])
  Ct.tmp <- th.cyc(capillaryPCR[, i], y.tmp, r = 50, linear = FALSE)
  abline(v = Ct.tmp[1])
  text(Ct.tmp[1] * 1.1, 1200, paste(round(Ct.tmp[1], 1), "\nmin"))
  lines(capillaryPCR[, i], y.tmp, type = "b", pch = 20 - i) 
  points(Ct.tmp@input, col = "red", pch = 19)
}
abline(h = 50)
legend("topleft", c("Run 1", "Run 2", "Run 3", "Control"), pch = c(19, 17, 15, 
13), lwd = 1.3, bty = "n")
@



<<workflow,fig.show='hold',fig.cap=fig4_cap,warning=FALSE>>=
layout(matrix(c(1,2,3,3), 2, 2, byrow = TRUE), respect = TRUE)

par(las = 0, bty = "n", oma = c(.5,.5,.5,.5))

th.cyc.raw <- apply(VIMCFX96_60[, -1], 2, function(i) {
		    th.cyc(VIMCFX96_60[, 1], i, r = 2575)[1,1]})

res.CPP <- apply(VIMCFX96_60[, -1], 2, function(i) {
		    CPP(VIMCFX96_60[, 1], i, trans = TRUE, 
			method.norm = "minmax")[["y.norm"]]})
		 
th.cyc.CPP <- apply(res.CPP, 2, function(i) {
		    th.cyc(VIMCFX96_60[, 1], i, r = 0.1)[1,1]})

matplot(VIMCFX96_60[, -1], type = "l", pch = 19, col = 1, lty = 1, 
	xlab = "Cycle", ylab = "Raw fluorescence", main = "Raw")
abline(h = 2575, lty = 2)
mtext("A", cex = 1.2, side = 3, adj = 0, font = 2)

matplot(res.CPP, type = "l", pch = 19, col = 1, lty = 1, xlab = "Cycle", 
	ylab = "Fluorescence", main = "CPP")
abline(h = 0.1, lty = 2)
mtext("B", cex = 1.2, side = 3, adj = 0, font = 2)

boxplot(data.frame(Raw = th.cyc.raw, CPP = th.cyc.CPP), ylab = "Cq (Ct)", 
	notch = TRUE)
mtext("C", cex = 1.2, side = 3, adj = 0, font = 2)
@


It is an intrinsic property of \textsl{AmpSim} to generate unique results if 
the $noise$ parameter is set $TRUE$. This is due the use of the \textsl{rnorm} 
(\emph{stats}) function to simulate noise. If data need to be replicated 
identically use \textsl{set.seed(123)} to alter the random number generator 
(RNG) state. For example, the amplification curves of 
Figure~S\ref{fig:AmpSim_effcalc}~\emph{A} are generated with the same 
starting 
parameter of \textsl{AmpSim} but noise signals were added. \textsl{AmpSim.gui} 
is a \emph{shiny} GUI (graphical user interface) implementation for 
\textsl{AmpSim}. Further details are described in section ``Graphical User 
Interface \& data import and export''. \textsl{AmpSim} was also used to 
illustrate the the \textsl{inder} function (Figure~S\ref{figure:SDM}), the 
\textsl{fixNA} function (Figure~S\ref{figure:fixNA}) and the use of the 
\textsl{smoother} (Figure~S\ref{figure:smoother}) function.


<<normalization,fig.show='hold',fig.cap=fig5_cap>>=
par(mfrow = c(2,3), las = 0, bty = "n", oma = c(.5,.5,.5,.5))
tmp <- VIMCFX96_60

plot(NA, NA, xlim = c(1,40), ylim = c(0, 6000), xlab = "Cycle", 
     ylab = "RFU", main = "Raw data")
mtext("A", cex = 1.2, side = 3, adj = 0, font = 2) 
lin <- apply(tmp[, -1], 2, function(x) lines(tmp[, 1], x))
abline(lm(rowMeans(tmp[2:10, 2L:ncol(tmp)]) ~ tmp[2:10, 1]), col = 2)

plot(NA, NA, xlim = c(1,40), ylim = c(0, 3300), xlab = "Cycle", 
     ylab = "RFU", main = "Baselined data")
mtext("B", cex = 1.2, side = 3, adj = 0, font = 2) 
lin <- apply(tmp[, -1], 2, function(x) lines(tmp[, 1], CPP(tmp[, 1], x, 
	method.norm = "none")$y))
	

plot(NA, NA, xlim = c(1,40), ylim = c(0, 1.15), xlab = "Cycle", 
     ylab = "RFU", main = "MinMax-Normalization")
mtext("C", cex = 1.2, side = 3, adj = 0, font = 2) 
lin <- apply(tmp[, -1], 2, function(x) lines(tmp[, 1], CPP(tmp[, 1], x, 
	method.norm = "minmax")$y))
	
plot(NA, NA, xlim = c(1,40), ylim = c(0, 1.15), xlab = "Cycle", 
     ylab = "RFU", main = "Max-Normalization")
mtext("D", cex = 1.2, side = 3, adj = 0, font = 2) 
lin <- apply(tmp[, -1], 2, function(x) lines(tmp[, 1], CPP(tmp[, 1], x,, 
	method.norm = "max")$y))
     
plot(NA, NA, xlim = c(1,40), ylim = c(0, 1.15), xlab = "Cycle", 
     ylab = "RFU", main = "luqn-Normalization")
mtext("E", cex = 1.2, side = 3, adj = 0, font = 2) 
lin <- apply(tmp[, -1], 2, function(x) lines(tmp[, 1], CPP(tmp[, 1], x, 
	method.norm = "luqn", qnL = 0.03)$y))

plot(NA, NA, xlim = c(1,40), ylim = c(-1.5, 1.5), xlab = "Cycle", 
     ylab = "RFU", main = "zscore-Normalization")
mtext("F", cex = 1.2, side = 3, adj = 0, font = 2) 
lin <- apply(tmp[, -1], 2, function(x) lines(tmp[, 1], CPP(tmp[, 1], x, 
	method.norm = "zscore")$y))
@



\subsection*{Analysis of quantification Cycle and Amplification Efficiency }

The output of \textsl{inder} includes the first derivative maximum ($FDM$) 
and second derivative maximum ($SDM$), which are commonly used in qPCR 
experiments. Figure~S\ref{figure:SDM} shows a typical result of the 
\textsl{inder} function. Following we show three examples explain properties of 
\textsl{inder} and to illustrate applications of the function in combination 
with other functions.

\emph{Example 1: Parameters of the \textsl{inder} function}

Figure~S\ref{figure:SDM} illustrates the most important parameters of the 
\textsl{inder} function. We used the \textsl{AmpSim} function to simulate an 
ideal ``noise-free'' amplification curve with the default setting to calculated 
the second derivative maximum ($SDM$) with \textsl{inder}. If $logy$ is $TRUE$ 
than a semi-decadic log scale graph (corresponds to the linear phase) to 
illustrate the exponential dynamic of the qPCR amplification is used. The 
parameter $logy$ is $FALSE$ is To our knowledge, \textsl{inder} is the first 
tool in \textbf{R} which allows user to numerically derive his data without 
fitting them to any function or combination of functions. The universality of 
stencil approach can find an application even in problems not related to the 
analysis of amplification curve.

\begin{figure*}
\begin{verbatim}
# AmpSim is used to generate an amplification curve with 40 cycles (approximate 
# Cq ~ 20) as object isPCR. isPCR is an object of the class "data.frame".
isPCR <- AmpSim(cyc = 1:40, Cq = 20)

# Invoke the inder function for the object isPCR to interpolate the derivatives 
# of the simulated data as object res. The Nip parameter was set to 5. This 
leads to smoother curves. res is an object of the class "der".

res <- inder(isPCR)

# Fetch the Cq values from res with the summary function
summ <- summary(res, print = FALSE)

# Print the summary of the object res.
summ

# FDM: first derivative maximum, SDM: second derivative maximum, SDm: second 
# derivative minimum, SDC: second derivative center.
#     FDM      SDM      SDm      SDC 
19.88679 18.90566 21.11321 19.97897
\end{verbatim}
\end{figure*}

\emph{Example 2: The \textsl{inder} function in combination with the 
\textsl{diffQ2} function}

\textsl{inder} is a helper function, which can be part of other routines. 
Recently, we added this approach to the \textsl{diffQ} function of the 
\emph{MBmca} for improved predictions. \textsl{diffQ} function is part of a 
routine to calculate the melting points of nucleic acids 
\cite{roediger_RJ_2013}.The $FDM$ and $SDM$ are peak values to determine the 
Cq. 
However, the presence of noise may cause many false estimates for the $FDM$ and 
$SDM$. To minimize this problem, it is possible to smooth the first derivative 
of the amplification curve. Provided that the smoother is properly adjusted, it 
is possible to detect only the significant peaks while small or to narrow peaks 
are ignored. \textsl{smoother} is 
used by other functions of $\emph{chipPCR}$ like \textsl{CPP}. The example for 
Figure~\ref{figure:inder} illustrates the use of 
the \textsl{diffQ} and \textsl{diffQ2} function from the \emph{MBmca} and the 
integration of the \textsl{inder} function. In contrast to the original 
publication \cite{roediger_RJ_2013} is the \textsl{inder} function in 
\textsl{diffQ} and \textsl{diffQ2} used for a precise peak location while the 
approaximate $SDM$ is calculated from the derivative of a quadratic function at 
the approximate $SDM$. 



\emph{Example 3: The \textsl{inder} function in combination with a 5-parameter 
curve fit function}

In the previous example we used smoothing and the \textsl{inder} method to 
calculate the $SDM$. But, smoothing may alter peak signal considerably. For 
example it is well known that peak height reduction peak width increase are 
common problem. An alternative technique to determine the $FDM$ of $SDM$ is by 
fitting the raw data. In the next example we used the \textsl{drm} function 
from 
the \emph{drc} package to fit a five-parameter log-logistic function to fit the 
S-shaped curves. The \textsl{inder} function was used to calculate the $SDM$ of 
the predicted models. for Figure~\ref{figure:inder_fit}




\textsl{th.cyc} function can also be used to calculate the quantification 
cycle. 
This function was implemented primarily for the analysis of amplification from 
qIA but also for qPCR. We implement a symmetrically approximation algorithm 
based on linear and quadratic least squares regression (see supplement for 
details).

  Various influences alter amplification reactions. A complex interaction of 
the 
intrinsic and extrinsic factors like reaction conditions, substrate 
consumption, 
primer dimmer formation and molecule specific reaction rates control the 
amplification efficiency \cite{mehra_2005}. Some probe systems are considered 
to 
introduce a bias. Therefore, qPCR reaction should be corrected based on the 
amplification efficiency \cite{tuomi_2010, ruijter_2014}. The amplification 
efficiency (AE) can be estimated from individual samples or a set of samples to 
compensate the presence of inhibitors and noise. Indirect methods use fitted 
mathematical models or estimate the AE from absolute fluorescence values 
\cite{tichopad_2003, liu_2002, alvarez_2007, smith_2007, batsch_2008, 
mallona_2011}. The \emph{qpcR} has many functions included, which can be used 
for the indirect estimation of the AE. However, most commonly used is the 
''direct method'' \cite{liu_2002, stahlberg_2003}. Herein, the AE is estimated 
from dilution series of an template. The AE of a qPCR reaction is calculated 
from the slope of the standard curve (Equation~S\ref{eq:AE}).

\begin{equation} \label{eq:AE}
AE = \frac{10^{(-1/m)}}{2} * 100
\end{equation}

The function \textsl{effcalc} is used for the automatic calculation of the AE 
of 
a dilution series (Figure~S\ref{figure:smoother}). An object of the class list 
contains the ``Concentration'', 
Cqs, deviation of the Cqs, "Coefficient of Variance" sequentially in the 
columns, the amplification efficiency (\%) according to Equation~S\ref{eq:AE}, 
the results of the linear regression and the correlation test (Pearson) 
results (see supplement for further details).

\begin{figure*}
\begin{verbatim}
par(las = 0, bty = "n", oma = c(.5,.5,.5,.5))
par(fig = c(0,0.5,0,1), new = TRUE)
plot(NA, NA, xlim = c(1,55), ylim = c(0, 0.7), xlab = "Cycle", 
     ylab = "refMFI", main = "Raw data")
apply(C54[, c(2:4)], 2, function(y) lines(C54[, 1], y))
mtext("A", cex = 1.2, side = 3, adj = 0, font = 2) 

par(fig = c(0.5,1,0.5,1), new = TRUE)
plot(NA, NA, xlim = c(1,55), ylim = c(0, 0.55), xlab = "Cycle", 
     ylab = "refMFI", main = "pre-processed data")
mtext("B", cex = 1.2, side = 3, adj = 0, font = 2) 

D1 <- cbind(C54[1:35, 1], CPP(C54[1:35, 1], C54[1:35, 2])[["y.norm"]])
D2 <- cbind(C54[1:45, 1], CPP(C54[1:45, 1], C54[1:45, 3])[["y.norm"]])
D3 <- cbind(C54[1:55, 1], CPP(C54[1:55, 1], C54[1:55, 4])[["y.norm"]])

lines(D1, col = 1)
lines(D2, col = 2)
lines(D3, col = 3)

dilution <- c(1E0, 1E-3, 1E-6)
Cq.D1 <- diffQ2(D1, inder = TRUE)[["xTm1.2.D2"]][1]
Cq.D2 <- diffQ2(D2, inder = TRUE)[["xTm1.2.D2"]][1]
Cq.D3 <- diffQ2(D3, inder = TRUE)[["xTm1.2.D2"]][1]

res.dil <- data.frame(dilution, rbind(Cq.D1, Cq.D2, Cq.D3))
par(fig = c(0.5,1,0,0.5), new = TRUE)
effcalc(res.dil[, 1], res.dil[, 2])
\end{verbatim}
\end{figure*}


<<AmpSim_effcalc,fig.show='hold',fig.cap=fig6_cap,message=FALSE>>=

# Load MBmca package (v. 0.0.3-3 or later)
require(MBmca)

# Create an graphic device for two empty plots.
par(mfrow = c(1,2))
plot(NA, NA, xlim = c(1,45), ylim = c(0.01,1.1), xlab = "Cycles", 
     ylab = "Fluorescence", main = "")
mtext("A", cex = 1.1, side = 3, adj = 0, font = 2)

# Create a sequence of "targeted" Cq values (Cq.t) between 15 and 34 cycles.

Cq.t <- rep(seq(15, 34, 3.5), 3)

# In-silico experiment set up: Define the levels for the decadic dilutions
# with concentrations from 100 to 0.001 (six steps) as three replicates.

dilution <-rep(sapply((2:-4), function(i) {10^i}), 3)

# Create an empty matrix for the results of the concentration
# dependent Cq values.

ma.out <- matrix(data = NA, nrow = 45, ncol = length(Cq.t))

# Use AmpSim to simulate amplification curves at different concentrations. 
# The simulation is performed with the addition of some noise. This generates 
# unique (non-reproducebale) amplification curves, even under idential paramter 
# settings.

Cq.out <- vector()
# Simulate a qPCR reaction with AmpSim for 45 cycles and some noise.

for (i in 1L:18) {
      ma.out[1:45, i] <- AmpSim(cyc = c(1:45), b.eff = -50, bl = 0.001, 
				ampl = 1, Cq = Cq.t[i], noise = TRUE, 
				nnl = 0.02)[, 2]
      lines(1:45, ma.out[, i])
      tmpP <- mcaSmoother(1:45, ma.out[, i])
# Calculate the pseudo Second Derivative Maximum (SDM) (Cq) using 
# the diffQ2 function from the MBmca package.
      Cq.tmp <- diffQ2(tmpP, inder = TRUE)$xTm1.2.D2[1]
      abline(v = Cq.tmp)
      Cq.out <- c(Cq.out, Cq.tmp)
}

# Assign the calculated Cqs to the corresponding concentrations.
tmp <- data.frame(dilution[1:6], Cq.out[1:6], Cq.out[7:12],  Cq.out[13:18])
		  
# Determine the amplification efficiency by using the effcalc function.
effcalc(tmp[, 1], tmp[, 2:4], CI = TRUE)
mtext("B", cex = 1.1, side = 3, adj = 0, font = 2) 
@


      

<<fixNA_CPP,fig.show='hold',fig.cap=fig7_cap,message=FALSE>>=

# Draw an empty plot for 45 cycles with user defined parameters.
layout(matrix(c(1,2,1,3), 2, 2, byrow = TRUE))
par(las = 0, bty = "n", oma = c(.5,.5,.5,.5))
    
plot(NA, NA, xlim = c(1,45), ylim = c(0, 0.7), xlab = "Cycle", 
     ylab = "refMFI", main = "Raw data")
mtext("A", cex = 1.2, side = 3, adj = 0, font = 2) 

# Take the first 45 cycles of the C54 data set and assign it to the
# object dat.
dat <- C54[1:45, ]

# Plot the amplification curve data.
apply(C54[, c(2:4)], 2, function(y) lines(C54[, 1], y))

# Draw an empty plot for the output of the preprocessed data.

plot(NA, NA, xlim = c(1,45), ylim = c(0, 0.55), xlab = "Cycle", 
     ylab = "refMFI", main = "Pre-processed data")
mtext("B", cex = 1.2, side = 3, adj = 0, font = 2) 

# Use CPP to preprocesses the data. CPP is used with the default parameters.
# This means: the slope of the background range is corrected by a linear 
# robust regression (MM-estimator), outliers are not removed, the curve is
# Smoothed be a Savitzky-Golay smoothing filter and NAs are removed by the 
# spline method. The results of CPP are assigned to the objects D1, D2, and D3.

D1 <- cbind(1:45, CPP(dat[, 1], dat[, 2])$y.norm)
D2 <- cbind(1:45, CPP(dat[, 1], dat[, 3])$y.norm)
D3 <- cbind(1:45, CPP(dat[, 1], dat[, 4])$y.norm)

# Plot the output of the preprocessed curves.
lines(D1, col = 1)
lines(D2, col = 2)
lines(D3, col = 3)

# Define the dilutions
dilution <- c(1E0, 1E-3, 1E-6)

# The function diffQ2 with the parameter "inder = TRUE" is used to calculate 
# the Cq value by means SDM. The results are assigned to the corresponding 
# concentration in the object res.

res <- data.frame(dilution, 
		  rbind(diffQ2(D1, inder = TRUE)$xTm1.2.D2[1], 
		        diffQ2(D2, inder = TRUE)$xTm1.2.D2[1], 
			diffQ2(D3, inder = TRUE)$xTm1.2.D2[1]
			)
		 )
# Finally the object res is used in effcalc to show the results  in the
# amplification efficiency plot.

effcalc(res[, 1], res[, 2])
@




      
\subsection{fixNA}


<<fixNA,fig.show='hold',fig.cap=fig8_cap>>=
# Simulation of an ideal amplification curve with 40 cycles
# The other parameter of the AmpSim function are identical to
# the default.

res <- AmpSim(cyc = 1:40)

# Introduce a missing value (cycle 18) in the transition between 
# the background and the exponential phase.
res.NA <- res
res.NA[18, 2] <- NA

# Helper function to highlight the position of the missing value.
abliner <- function(x1 = 17.5, x2 = 18.5, y1 = 0.09, y2 = 0.14) {
		abline(v = c(x1, x2), col = "red")
		abline(h = c(y1, y2), col = "red")
	    }

par(las = 0, mfrow = c(2,2), bty = "n")
plot(res, xlab = "Cycles", ylab = "RFI", type = "b", pch = 20, 
     main = "Without NA")
abliner()
mtext("A", cex = 1.2, side = 3, adj = 0, font = 2)
res.NA.linear <- fixNA(res.NA[, 1], res.NA[, 2], spline = FALSE, 
		       verbose = FALSE)

plot(res.NA, xlab = "Cycles", ylab = "RFI", type = "b", pch = 20, 
     main = "With NA during transition")
abliner()
mtext("B", cex = 1.2, side = 3, adj = 0, font = 2)

res.NA.spline <- fixNA(res.NA[, 1], res.NA[, 2], spline = TRUE, 
		       verbose = FALSE)
	       
plot(res.NA.linear, xlab = "Cycles", ylab = "RFI", type = "b", 
     pch = 20, main = "Linear imputed\n NA")
abliner()
mtext("C", cex = 1.2, side = 3, adj = 0, font = 2)
     
plot(res.NA.spline, xlab = "Cycles", ylab = "RFI", type = "b", 
      pch = 20, main = "Spline imputed\n NA")
abliner()
mtext("D", cex = 1.2, side = 3, adj = 0, font = 2)
par(mfrow = c(1,1))
@

\section{UNSORTED}
     

<<SDM,fig.show='hold',fig.cap=fig9_cap>>=
# Use AmpSim to generate an amplification curve with 40 cycles
# and an approximate Cq of 20 and assign it to the object isPCR.
# isPCR is an object of the class "data.frame".
isPCR <- AmpSim(cyc = 1:40, Cq = 20)

# Invoke the inder function for the object isPCR to interpolate 
# the derivatives of the simulated data as object res. The Nip 
# parameter was set to 5. This leads to smoother curves. res is
# an object of the class "der".
res <- inder(isPCR, Nip = 5)

# Plot the the object res and add descriptions to the elements.

par(las = 0, bty = "n", oma = c(.5,.5,.5,.5))

plot(isPCR, xlab = "Cycle", ylab = "RFU", ylim = c(-0.15,1),
     main = "", type = "b", pch = 20, lwd = 2)
colors <- rainbow(4)
# Add graphical elements for the dervatives and the calculated
# Cq values FDM, SDM, SDm and SDC.

  lines(res[, "x"], res[, "d1y"], col = "blue", lwd = 2)
  lines(res[, "x"], res[, "d2y"], col = "red", lwd = 2)
  
# Fetch the Cq values from res with the summary function
  summ <- summary(res, print = FALSE)
  
  abline(v = summ, col = colors, lwd = 2)
  text(15, 0.3, paste("FDM ~ ", round(summ["FDM"], 2)), 
       cex = 1.1, col = colors[1])
  text(15, 0.2, paste("SDM ~ ", round(summ["SDM"], 2)), 
       cex = 1.1, col = colors[2])
  text(15, - 0.1, paste("SDm ~ ", round(summ["SDm"], 2)), 
       cex = 1.1, col = colors[3])
  text(15, 0.7, paste("SDC ~ ", round(summ["SDC"], 2)), 
       cex = 1.1, col = colors[4])
       
  legend(1.1, 0.9, c("raw", "first derivative", "second derivative"), 
         col = c(1,4,2), lty = c(2,1,1), bty = "n")

# Summary of the object res.
summ
#     FDM      SDM      SDm      SDC 
#19.81407 19.03015 20.98995 19.98604
@

            

<<inder,fig.show='hold',fig.cap=fig10_cap,message=FALSE,results='hide'>>=
# Plot all data from C127EGHP and calculate the SDM (Second Derivative 
# Maximum) values with the diffQ2() function (Note: the inder parameter
# is set as TRUE)
# first plot the samples detected with EvaGreen and next the samples 
# detected with the Hydrolysis probe

pointer <- function (x, pos = 1, w = 5, stat = TRUE){
  xx <- pos + rep(seq(-0.1, 0.1, length.out = w), ceiling(length(x)/w))
  yy <- sort(x)
  points(xx[1:length(yy)], yy, pch = 19)
  
  if (stat == TRUE)
    x.median <- median(x, na.rm = T)
    x.mad <- mad(x, na.rm = T) * 2
    param <- c(length= 0, code = 3, pch = 15, cex = 1.2)
    arrows(xx[1] * 0.98, x.median, tail(xx, 1) * 1.02, 
	    x.median, param, lwd = 3)
    arrows(xx[1] * 1.01, x.median + x.mad, tail(xx, 1) * 0.99, 
	    x.median + x.mad, param, lwd = 2, lty = 2)
    arrows(xx[1] * 1.01, x.median - x.mad, tail(xx, 1) * 0.99, 
	    x.median - x.mad, param, lwd = 2, lty = 2)
}

amp.liner <- function(range, input, colors = "black") {
  sapply(range, function(i) {
	 lines(input[, 2], input[, i], col = colors, pch = 19)
	 tmpP <- mcaSmoother(input[, 2], input[, i])
	 SDM <- diffQ2(tmpP, inder = TRUE)[["xTm1.2.D2"]][1]
	 abline(v = SDM)
	 SDM
       }
  )
}

par(mfrow = c(1,3), las = 0, bty = "n")
plot(NA, NA, xlim = c(1,40), ylim = c(0,10), xlab = "Cycle", 
      ylab = "Fluorescence", main = "EvaGreen")
mtext("A", cex = 1.1, side = 3, adj = 0, font = 2)

EG <- amp.liner(range = 3L:34, input = C127EGHP)
  
plot(NA, NA, xlim = c(1,40), ylim = c(0,10), xlab = "Cycle", 
      ylab = "Fluorescence", main = "Hydrolysis probe")
mtext("B", cex = 1.1, side = 3, adj = 0, font = 2)

HP <- amp.liner(range = 35L:66, input = C127EGHP)

plot(NA, NA, xlim = c(0.8,2.2), ylim = c(13,14), xaxt = "n", 
     xlab = "", ylab = "Cq (SDM, diffQ2)")
text(c(1.05,2), c(13.05,13.05), c("EG", "HP"), cex = 1.2)
mtext("C", cex = 1.1, side = 3, adj = 0, font = 2)
pointer(EG, pos = 1, w = 8)
pointer(HP, pos = 2, w = 8)
@


      

<<inder_fit,fig.cap=fig11_cap,fig.show='hold',message=FALSE,results='hide'>>=
fit.amp <- function(cyc, fluo, plot = FALSE) {

	ampl <- quantile(fluo, 0.999)
	bl <- quantile(fluo, 0.001)
	Cq <- round(mean(cyc))
	b.eff <- 1
	
 	fit <- nls(fluo ~ bl + ampl / (1 + exp(- (cyc - Cq) / b.eff)), 
 		     start = list(Cq = Cq, b.eff = b.eff, ampl = ampl, 
 		     bl = bl)
 		     )
	
	res.pred <- data.frame(cyc, predict(fit))
	res <- inder(res.pred[, 1], res.pred[, 2])
	if (plot) {
	    lines(res[, 1], res[, 4])
	}
	summary(res)[2] # SDM
}

tmp <- C126EG595

out <- apply(tmp[, -1], 2, function(x) fit.amp(tmp[, 1], x))

layout(matrix(c(1,2,1,3), 2, 2, byrow = TRUE))

plot(NA, NA, xlim = c(1,40), ylim = c(min(tmp[, 2L:97]), 
     max(tmp[, 2L:97])), xlab = "Cycle", ylab = "Raw fluorescence")
mtext("A", cex = 1.2, side = 3, adj = 0, font = 2)
for (i in 2L:97) {
    lines(tmp[, 1], tmp[, i], col = ifelse(out[i - 1] < 15.5, "red", "black"), 
lwd = 2)
  }
abline(v = out)

plot(NA, NA, xlab = "Cycle", ylab = "RFU''(Cycle)", main = "", xlim = c(0,40), 
     ylim = c(-850, 850))
invisible(apply(tmp[, -1], 2, function(x) {
    fit.amp(tmp[, 1], x, plot = TRUE)
  }
))
mtext("B", cex = 1.2, side = 3, adj = 0, font = 2)

hist(out, xlab = "Cq (SDM)", main = "", 
     breaks = seq(14.8, 15.8, 0.05), col = rainbow(96))
abline(v = 15.5, lty = 2)
mtext("C", cex = 1.2, side = 3, adj = 0, font = 2)
@

      
      \begin{figure}
  \caption{\label{figure:bgmax} \textsl{bg.max} 
tries to estimate the range between the background and the plateau phase of an 
amplification reaction. \emph{(A)} in absence and \emph{(B)} presence of noise. 
}
      \end{figure} 

\section{Visualizing data}

After introductory steps, more in-depth analysis of experiments is required. Let's make a
close-up of the experiment F1.2.


\textsl{bg.max} function provides the user with different information. Firstly, it estimates 
the beginning and the end of amplification reaction. Secondly, it defines range of the 
background which could be helpful for example in calculation of the background correction.

\section{Acknowledgment}

  Part of this work was funded by the BMBF InnoProfile-Projekt 03 IPT 611X. 
Grateful thanks belong to all authors of the cited R packages, the R community 
and RKWard developers.

% if your bibliography is in bibtex format, use those commands:
\bibliographystyle{plain} % Style BST file
\bibliography{roediger-burdukiewicz}      % Bibliography file (usually '*.bib' )


\end{document}